# 1st-repository

Overall description of our robotic solution

First things first what we need is the brain which was fed with all the code we did.
We utilized the programming language C++. The brain is the one that send, receives and analyzed the information; with the help of the code, it will compare and analyze the data.

Our robot does 3 important steps: collects information, processes it, and acts upon it.
Information gathering: Through the sensors we used, which are: the Ultrasonic sensor and the camera which help with collecting information on its place at any point in time. If its close or far away from an object and what side has more space to turn. The camera doesn’t require additional coding and can easily detect the distance, but then after many tries we found out that in some cases the ultrasonic sensor isn’t able to detect the distance correctly, meanwhile the camera, apart from detecting the distance, can also detect the colors of obstacles present in the second challenge of the race, but it is a bit problematic when it comes to coding since it is not compatible with the first language of coding that we were using at the start.

Information processing: The element of hardware which processes the information in our robot is the brain, in the code we inserted multiple instructions which adapt a both challenges of the race. The brain receives the first part of the information, then it goes through the procedure written in the code and finally send the information into the energy system, thus sending energy to the servo which then turns in the direction that the brain sent it to turn.

Acting by the code: After sending the information through the energy system the energy system to turn on the propulsion motors and the servo motor, also known as the direction motor, the propulsion motor is the one that makes it possible for our robot to advance and the servo or direction motor is the one that makes it possible for our robot to turn left and right with the desired angle stated in the coding.

Code: The hardest part of our robot is the coding, the first challenge, the easiest one, is that the robot needs to turn and follow the course without crash0ing into the internal and external walls, to complete this challenge we need to use our 2 ultrasonic sensors on the sides of the robot to detect if it has or hasn’t an obstacle on its sides, if there was an obstacle then it would try to dodge it, however when it doesn’t detect an obstacle  it will steer into the area where there aren’t any obstacles.
For the second challenge, which has a larger difficulty, the robot has to not only evade the walls like the first objective but also it has to turn in a direction indicated in the code depending on the color of the obstacle, which in this case will be either red or green, but for this task it will not use the ultrasonic sensors, as they can’t detect color so the robot will use the camera which is able to detect the color of the obstacle and steer in the desired path according to the coding. The camera has a special function to let us visualize what the camera is watching live, this function lets us choose what objects to identify, these save into the camera’s memory, in this case it being the color of the obstacle which we can select for the camera to identify due to the camera detection being made out of pixels which we can select easily, when the camera detects something a white-translucent square appears over the object to show that it is detecting something, this appears in the live feed during testing. We decided to save the colors red and green since they are the ones needed in the second challenge.

One of the aspects which was the most challenging at the moment of programming was keeping it in the same lane where it was initially placed, we used the variable “Lane”, what this variable does is maintain the robot in the same lane that was originally used, this works by, at the start, measuring the distance between the internal and external wall, then that distance is coded into the variable and the robot is told to stay in that range, getting this value: if it’s in the internal lane the variable is 1, in the middle it’s 2, and in the external it’s 3, with this 3 functions are chosen for each lane, depending on which variable is chosen due to the initial measurements by the sensors the robot choses one of the 3 variables and follows the path that the coding dictates, for example, in the first case if the robot detects that the range is 5 centimeters on one sensor and 27 centimeters in the other sensor, it will try to stay on that distance, but if suddenly the 5 centimeters sensor detects that the robot is less than 5 centimeters away it will turn the robot to the right or left depending on the initial direction, and if it detects less than 27 centimeters it will also turn the robot right or left depending on the initial direction as well, this also happens with the other 2 variables, each one having a different set distance, however and override can happen if the camera detects a color, turning the robot in the set direction even if the sensors would want it otherwise, but as soon as the camera stop detecting the color, the ultrasonic sensors will take over again and keep the robot in the desired direction as soon as possible.

Once started the robot doesn’t stop, in fact it will keep going at all times until a certain time is reached, this time was carefully taken through testing, to make sure that the robot stays as close, if not in the same area where it originally started, while there could have been more methods to return the robot to its original starting place, due to limited materials we did the best without code, software and hardware.
It was noted that the robot would consume a full pack of 4 AA Batteries quickly, which are connected in series to the brain which distributes the energy into the camera, ultra sonic sensors and servo and propulsion motor.

With these the robot successfully stays in the desired path and successfully completes the course with maximum efficiency, easily avoiding all the obstacles and walls, and finally keeping itself in the best time and path cited for each challenge’s course, even if one of the sensors fail, which can happen, won’t affect the robot’s final performance in the end of it all.
